{"ast":null,"code":"import Vue from 'vue';\nimport Router from 'vue-router';\nimport RoutePrefetch from 'vue-router-prefetch';\nimport routes from '#cache/routes';\nVue.use(Router); // Make `<RouterLink>` prefetch-able\n\nVue.use(RoutePrefetch, {\n  componentName: 'SaberLink',\n  // Only enable prefetching in production mode\n  prefetch: process.env.NODE_ENV === 'production'\n});\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual'; // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n\n    window.addEventListener('beforeunload', () => {\n      window.history.scrollRestoration = 'auto';\n    }); // Setting scrollRestoration to manual again when returning to this page.\n\n    window.addEventListener('load', () => {\n      window.history.scrollRestoration = 'manual';\n    });\n  }\n}\n\nexport default (() => {\n  const createRouter = routes => new Router({\n    mode: 'history',\n    routes,\n    base: __PUBLIC_URL__,\n\n    scrollBehavior(to, from, savedPosition) {\n      // if the returned position is falsy or an empty object,\n      // will retain current scroll position.\n      let position = false; // if no children detected and scrollToTop is not explicitly disabled\n\n      if (to.matched.length < 2 && to.matched.every(r => r.components.default.scrollToTop !== false)) {\n        // scroll to the top of the page\n        position = {\n          x: 0,\n          y: 0\n        };\n      } else if (to.matched.some(r => r.components.default.scrollToTop)) {\n        // if one of the children has scrollToTop option set to true\n        position = {\n          x: 0,\n          y: 0\n        };\n      } // savedPosition is only available for popstate navigations (back button)\n\n\n      if (savedPosition) {\n        position = savedPosition;\n      }\n\n      return new Promise(resolve => {\n        const fulfill = () => {\n          // coords will be used if no selector is provided,\n          // or if the selector didn't match any element.\n          if (to.hash) {\n            const hash = decodeURIComponent(to.hash);\n\n            if (document.getElementById(hash.substr(1))) {\n              // scroll to anchor by returning the selector\n              position = {\n                selector: hash\n              };\n            } else {\n              // scroll to top if anchor does not exist and position is not already set\n              position = position || {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n\n          resolve(position);\n        }; // wait for the out transition to complete (if necessary)\n\n\n        if (to.path === from.path) {\n          fulfill();\n        } else {\n          router.app.$once('trigger-scroll', fulfill);\n        }\n      });\n    }\n\n  });\n\n  const router = createRouter(routes);\n\n  if (__LAZY__) {\n    let hasPrevPage = false;\n    const visitedRoutes = {};\n    router.beforeEach((to, from, next) => {\n      if (!hasPrevPage || visitedRoutes[to.path]) return next();\n      next(false);\n      visitedRoutes[to.path] = true;\n      fetch('/_saber/visit-page?route=' + encodeURIComponent(to.fullPath));\n    });\n    router.afterEach(() => {\n      hasPrevPage = true;\n    });\n  }\n\n  if (module.hot) {\n    module.hot.accept('#cache/routes', () => {\n      router.options.routes = routes;\n      router.matcher = createRouter(require('#cache/routes').default).matcher;\n    });\n  }\n\n  return router;\n});","map":{"version":3,"sources":["/Users/pence/Desktop/projects/black-000/black-000-2020/node_modules/saber/vue-renderer/app/router.js"],"names":["Vue","Router","RoutePrefetch","routes","use","componentName","prefetch","process","env","NODE_ENV","client","window","history","scrollRestoration","addEventListener","createRouter","mode","base","__PUBLIC_URL__","scrollBehavior","to","from","savedPosition","position","matched","length","every","r","components","default","scrollToTop","x","y","some","Promise","resolve","fulfill","hash","decodeURIComponent","document","getElementById","substr","selector","path","router","app","$once","__LAZY__","hasPrevPage","visitedRoutes","beforeEach","next","fetch","encodeURIComponent","fullPath","afterEach","module","hot","accept","options","matcher","require"],"mappings":"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","sourcesContent":["import Vue from 'vue'\nimport Router from 'vue-router'\nimport RoutePrefetch from 'vue-router-prefetch'\nimport routes from '#cache/routes'\n\nVue.use(Router)\n// Make `<RouterLink>` prefetch-able\nVue.use(RoutePrefetch, {\n  componentName: 'SaberLink',\n  // Only enable prefetching in production mode\n  prefetch: process.env.NODE_ENV === 'production'\n})\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual'\n\n    // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n    window.addEventListener('beforeunload', () => {\n      window.history.scrollRestoration = 'auto'\n    })\n\n    // Setting scrollRestoration to manual again when returning to this page.\n    window.addEventListener('load', () => {\n      window.history.scrollRestoration = 'manual'\n    })\n  }\n}\n\nexport default () => {\n  const createRouter = routes =>\n    new Router({\n      mode: 'history',\n      routes,\n      base: __PUBLIC_URL__,\n      scrollBehavior(to, from, savedPosition) {\n        // if the returned position is falsy or an empty object,\n        // will retain current scroll position.\n        let position = false\n\n        // if no children detected and scrollToTop is not explicitly disabled\n        if (\n          to.matched.length < 2 &&\n          to.matched.every(r => r.components.default.scrollToTop !== false)\n        ) {\n          // scroll to the top of the page\n          position = { x: 0, y: 0 }\n        } else if (to.matched.some(r => r.components.default.scrollToTop)) {\n          // if one of the children has scrollToTop option set to true\n          position = { x: 0, y: 0 }\n        }\n\n        // savedPosition is only available for popstate navigations (back button)\n        if (savedPosition) {\n          position = savedPosition\n        }\n\n        return new Promise(resolve => {\n          const fulfill = () => {\n            // coords will be used if no selector is provided,\n            // or if the selector didn't match any element.\n            if (to.hash) {\n              const hash = decodeURIComponent(to.hash)\n              if (document.getElementById(hash.substr(1))) {\n                // scroll to anchor by returning the selector\n                position = { selector: hash }\n              } else {\n                // scroll to top if anchor does not exist and position is not already set\n                position = position || { x: 0, y: 0 }\n              }\n            }\n            resolve(position)\n          }\n\n          // wait for the out transition to complete (if necessary)\n          if (to.path === from.path) {\n            fulfill()\n          } else {\n            router.app.$once('trigger-scroll', fulfill)\n          }\n        })\n      }\n    })\n\n  const router = createRouter(routes)\n\n  if (__LAZY__) {\n    let hasPrevPage = false\n    const visitedRoutes = {}\n\n    router.beforeEach((to, from, next) => {\n      if (!hasPrevPage || visitedRoutes[to.path]) return next()\n\n      next(false)\n\n      visitedRoutes[to.path] = true\n      fetch('/_saber/visit-page?route=' + encodeURIComponent(to.fullPath))\n    })\n\n    router.afterEach(() => {\n      hasPrevPage = true\n    })\n  }\n\n  if (module.hot) {\n    module.hot.accept('#cache/routes', () => {\n      router.options.routes = routes\n      router.matcher = createRouter(require('#cache/routes').default).matcher\n    })\n  }\n\n  return router\n}\n"]},"metadata":{},"sourceType":"module"}